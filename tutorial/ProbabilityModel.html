<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.18.2 + Helium Theme" />
    <title>Probability Model</title>
    
    
      <meta name="description" content="axle-docs"/>
    
    
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    
    <link rel="stylesheet" type="text/css" href="../helium/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../helium/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../css/main.scss" />
    <script src="../helium/laika-helium.js"></script>
    
    
    <script> /* for avoiding page load transitions */ </script>
  </head>

  <body>

    <header id="top-bar">

      <div class="row">
        <a id="nav-icon">
          <i class="icofont-laika" title="Navigation">&#xefa2;</i>
        </a>
        
      </div>
  
      <a class="icon-link" href="../index.html"><i class="icofont-laika" title="Home">&#xef47;</i></a>
      
      <span class="row links"></span>
      
    </header>

    <nav id="sidebar">

      <div class="row">
        
      </div>
      
      <ul class="nav-list">
        <li class="level1"><a href="../Architecture.html">Architecture</a></li>
        <li class="level1"><a href="../Author.html">Author</a></li>
        <li class="level1"><a href="../History.html">History</a></li>
        <li class="level1"><a href="../Index.html">Axle</a></li>
        <li class="level1"><a href="../ReleaseNotes.html">Release Notes</a></li>
        <li class="level1"><a href="../Resources.html">Resources</a></li>
        <li class="level1"><a href="../RoadMap.html">Road Map</a></li>
        <li class="level1"><a href="../Spokes.html">Spokes</a></li>
        <li class="level1"><a href="../Tutorials.html">Tutorials</a></li>
        <li class="level1"><a href="../Videos.html">Videos</a></li>
        <li class="level1 nav-header">tutorial</li>
        <li class="level2"><a href="Ackermann.html">Ackermann</a></li>
        <li class="level2"><a href="Algebra.html">Algebra</a></li>
        <li class="level2"><a href="AngluinLearner.html">Angluin Learner</a></li>
        <li class="level2"><a href="BarCharts.html">Bar Charts</a></li>
        <li class="level2"><a href="BayesianNetworks.html">Bayesian Networks</a></li>
        <li class="level2"><a href="Bioinformatics.html">Bioinformatics</a></li>
        <li class="level2"><a href="ClusterFederalistPapers.html">Clusters Federalist Papers</a></li>
        <li class="level2"><a href="ClusterIrises.html">Cluster Irises</a></li>
        <li class="level2"><a href="CoinEntropy.html">Entropy of a Biased Coin</a></li>
        <li class="level2"><a href="EditDistance.html">Edit Distance</a></li>
        <li class="level2"><a href="Fibonacci.html">Fibonacci</a></li>
        <li class="level2"><a href="GameTheory.html">Game Theory</a></li>
        <li class="level2"><a href="GeneticAlgorithms.html">Genetic Algorithms</a></li>
        <li class="level2"><a href="GeoCoordinates.html">Geo Coordinates</a></li>
        <li class="level2"><a href="GoldParadigm.html">Gold Paradigm</a></li>
        <li class="level2"><a href="Graph.html">Graph</a></li>
        <li class="level2"><a href="GroupedBarCharts.html">Grouped Bar Charts</a></li>
        <li class="level2"><a href="InformationTheory.html">Information Theory</a></li>
        <li class="level2"><a href="Installation.html">Installation</a></li>
        <li class="level2"><a href="LanguageModules.html">Language Modules</a></li>
        <li class="level2"><a href="LinearAlgebra.html">Linear Algebra</a></li>
        <li class="level2"><a href="LinearRegression.html">Linear Regression</a></li>
        <li class="level2"><a href="Linguistics.html">Linguistics</a></li>
        <li class="level2"><a href="Logic.html">Logic</a></li>
        <li class="level2"><a href="LogisticMap.html">Logistic Map</a></li>
        <li class="level2"><a href="MachineLearning.html">Machine Learning</a></li>
        <li class="level2"><a href="Mandelbrot.html">Mandelbrot Set</a></li>
        <li class="level2"><a href="MeanAveragePrecisionAtK.html">Mean Average Precision at K</a></li>
        <li class="level2"><a href="MontyHall.html">Monty Hall</a></li>
        <li class="level2"><a href="NaiveBayesClassifier.html">Naive Bayes</a></li>
        <li class="level2"><a href="NaturalLanguageProcessing.html">Natural Language Processing</a></li>
        <li class="level2"><a href="NeedlemanWunsch.html">Needleman-Wunsch</a></li>
        <li class="level2"><a href="PackageObject.html">Package Objects</a></li>
        <li class="level2"><a href="Pi.html">Pi</a></li>
        <li class="level2"><a href="PixelatedColoredArea.html">Pixelated Colored Area</a></li>
        <li class="level2"><a href="Plots.html">Plots</a></li>
        <li class="level2"><a href="Poker.html">Poker</a></li>
        <li class="level2"><a href="PrisonersDilemma.html">Prisoner&#39;s Dilemma</a></li>
        <li class="level2"><a href="ProbabilisticGraphicalModels.html">Probabilistic Graphical Models</a></li>
        <li class="level2 active"><a href="#">Probability Model</a></li>
        <li class="level2"><a href="PythagoreanMeans.html">Pythagorean Means</a></li>
        <li class="level2"><a href="Python2Json.html">python2json.py</a></li>
        <li class="level2"><a href="Quanta.html">Quanta</a></li>
        <li class="level2"><a href="ReservoirSampling.html">Reservoir Sampling</a></li>
        <li class="level2"><a href="RootMeanSquareDeviation.html">Root-mean-square deviation</a></li>
        <li class="level2"><a href="ScatterPlot.html">Scatter Plot</a></li>
        <li class="level2"><a href="SmithWaterman.html">Smith-Waterman</a></li>
        <li class="level2"><a href="Statistics.html">Statistics</a></li>
        <li class="level2"><a href="TicTacToe.html">Tic Tac Toe</a></li>
        <li class="level2"><a href="UnittedTrigonometry.html">Unitted Trigonometry</a></li>
        <li class="level2"><a href="VectorSpaceModel.html">Vector Space Model</a></li>
        <li class="level2"><a href="Visualize.html">Visualize</a></li>
      </ul>
      
    </nav>

    <div id="container">

      <nav id="page-nav">
        <p class="header"><a href="#">Probability Model</a></p>
        
        <ul class="nav-list">
          <li class="level1"><a href="#imports">Imports</a></li>
          <li class="level1"><a href="#creating-probability-models">Creating Probability Models</a></li>
          <li class="level1"><a href="#sampler">Sampler</a></li>
          <li class="level1"><a href="#sigma-algebra-regions">Sigma Algebra Regions</a></li>
          <li class="level2"><a href="#arity-0">Arity 0</a></li>
          <li class="level2"><a href="#arity-1-not-including-typeclass-witnesses">Arity 1 (not including typeclass witnesses)</a></li>
          <li class="level2"><a href="#arity-2">Arity 2</a></li>
          <li class="level1"><a href="#kolmogorov-for-querying-probability-models">Kolmogorov for querying Probability Models</a></li>
          <li class="level2"><a href="#probabilityof-aka-p">probabilityOf (aka &quot;P&quot;)</a></li>
          <li class="level2"><a href="#kolmogorov-s-axioms">Kolmogorov&#39;s Axioms</a></li>
          <li class="level1"><a href="#bayes-theorem-conditioning-and-filtering">Bayes Theorem, Conditioning, and Filtering</a></li>
          <li class="level1"><a href="#probability-model-as-monads">Probability Model as Monads</a></li>
          <li class="level2"><a href="#monad-laws">Monad Laws</a></li>
          <li class="level2"><a href="#monad-syntax">Monad Syntax</a></li>
          <li class="level2"><a href="#chaining-models">Chaining models</a></li>
          <li class="level1"><a href="#summing-two-dice-rolls">Summing two dice rolls</a></li>
          <li class="level2"><a href="#iffy">Iffy</a></li>
          <li class="level2"><a href="#further-reading">Further Reading</a></li>
          <li class="level1"><a href="#future-work">Future work</a></li>
          <li class="level2"><a href="#measure-theory">Measure Theory</a></li>
          <li class="level2"><a href="#markov-categories">Markov Categories</a></li>
          <li class="level2"><a href="#probabilistic-and-differentiable-programming">Probabilistic and Differentiable Programming</a></li>
        </ul>
        
        <p class="footer"></p>
      </nav>

      <main class="content">

        <h1 id="probability-model" class="title">Probability Model</h1>
        <p>Modeling probability, randomness, and uncertainly is one of the primary objectives of Axle.</p>
        <p>The capabilies are available via four typeclasses and one trait</p>
        <ul>
          <li>Sampler</li>
          <li>Region (trait modeling σ-algebra)</li>
          <li>Kolmogorov</li>
          <li>Bayes</li>
          <li>Monad (<code>cats.Monad</code>)</li>
        </ul>
        <p>Concrete number type are avoided in favor of structures from Abstract Algebra -- 
        primarily <code>Ring</code> and <code>Field</code>.
        These are represented as context bounds, usually passed implicitly.</p>
        <p>The examples in this document use the <code>spire.math.Rational</code> number type, but work as well
        for <code>Double</code>, <code>Float</code>, etc.
        The precise number type <code>Rational</code> is used in tests because their precision allows the assertions to be expressed without any error tolerance.</p>
        
        <h2 id="imports" class="section"><a class="anchor-link left" href="#imports"><i class="icofont-laika">&#xef71;</i></a>Imports</h2>
        <p>Preamble to pull in the commonly-used functions in this document:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">effect</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">math</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">algebra</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">import</span><span> </span><span class="identifier">axle</span><span>.</span><span class="identifier">probability</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">axle</span><span>.</span><span class="identifier">algebra</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">axle</span><span>.</span><span class="identifier">visualize</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">axle</span><span>.</span><span class="identifier">web</span><span>.</span><span class="identifier">_</span></code></pre>
        
        <h2 id="creating-probability-models" class="section"><a class="anchor-link left" href="#creating-probability-models"><i class="icofont-laika">&#xef71;</i></a>Creating Probability Models</h2>
        <p>There are a few type of probability models in Axle.
        The simplest is the <code>ConditionalProbabilityTable</code>, which is used throughout this document.</p>
        <p><code>axle.data.Coin.flipModel</code> demonstrates a very simple probability model for type <code>Symbol</code>.</p>
        <p>This is its implementation:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">head</span><span> = </span><span class="type-name">Symbol</span><span>(</span><span class="string-literal">&quot;HEAD&quot;</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">tail</span><span> = </span><span class="type-name">Symbol</span><span>(</span><span class="string-literal">&quot;TAIL&quot;</span><span>)

</span><span class="keyword">def</span><span> </span><span class="declaration-name">flipModel</span><span>(</span><span class="identifier">pHead</span><span>: </span><span class="type-name">Rational</span><span> = </span><span class="type-name">Rational</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>)): </span><span class="type-name">ConditionalProbabilityTable</span><span>[</span><span class="type-name">Symbol</span><span>, </span><span class="type-name">Rational</span><span>] =
  </span><span class="type-name">ConditionalProbabilityTable</span><span>[</span><span class="type-name">Symbol</span><span>, </span><span class="type-name">Rational</span><span>](
    </span><span class="type-name">Map</span><span>(
      </span><span class="identifier">head</span><span> -&gt; </span><span class="identifier">pHead</span><span>,
      </span><span class="identifier">tail</span><span> -&gt; (</span><span class="number-literal">1</span><span> - </span><span class="identifier">pHead</span><span>)))</span></code></pre>
        <p>Its argument is the bias for the <code>HEAD</code> side.
        Without a provided bias, it is assumed to be a fair coin.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">fairCoin</span><span> = </span><span class="identifier">flipModel</span><span>()
</span><span class="comment">// fairCoin: ConditionalProbabilityTable[Symbol, Rational] = ConditionalProbabilityTable(
//   p = Map(&#39;HEAD -&gt; 1/2, &#39;TAIL -&gt; 1/2)
// )
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">biasedCoin</span><span> = </span><span class="identifier">flipModel</span><span>(</span><span class="type-name">Rational</span><span>(</span><span class="number-literal">9</span><span>, </span><span class="number-literal">10</span><span>))
</span><span class="comment">// biasedCoin: ConditionalProbabilityTable[Symbol, Rational] = ConditionalProbabilityTable(
//   p = Map(&#39;HEAD -&gt; 9/10, &#39;TAIL -&gt; 1/10)
// )</span></code></pre>
        <p>Rolls of dice are another common example.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">rollModel</span><span>(</span><span class="identifier">n</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">ConditionalProbabilityTable</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Rational</span><span>] =
  </span><span class="type-name">ConditionalProbabilityTable</span><span>(
    (</span><span class="number-literal">1</span><span> </span><span class="identifier">to</span><span> </span><span class="identifier">n</span><span>).</span><span class="identifier">map</span><span>(</span><span class="identifier">i</span><span> =&gt; (</span><span class="identifier">i</span><span>, </span><span class="type-name">Rational</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="identifier">n</span><span>.</span><span class="identifier">toLong</span><span>))).</span><span class="identifier">toMap</span><span>)</span></code></pre>
        <p>The values <code>d6</code> and <code>d10</code> model rolls of 6 and 10-sided dice.</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">d6</span><span> = </span><span class="identifier">rollModel</span><span>(</span><span class="number-literal">6</span><span>)
</span><span class="comment">// d6: ConditionalProbabilityTable[Int, Rational] = ConditionalProbabilityTable(
//   p = HashMap(5 -&gt; 1/6, 1 -&gt; 1/6, 6 -&gt; 1/6, 2 -&gt; 1/6, 3 -&gt; 1/6, 4 -&gt; 1/6)
// )
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">d10</span><span> = </span><span class="identifier">rollModel</span><span>(</span><span class="number-literal">10</span><span>)
</span><span class="comment">// d10: ConditionalProbabilityTable[Int, Rational] = ConditionalProbabilityTable(
//   p = HashMap(
//     5 -&gt; 1/10,
//     10 -&gt; 1/10,
//     1 -&gt; 1/10,
//     6 -&gt; 1/10,
//     9 -&gt; 1/10,
//     2 -&gt; 1/10,
//     7 -&gt; 1/10,
//     3 -&gt; 1/10,
//     8 -&gt; 1/10,
//     4 -&gt; 1/10
//   )
// )</span></code></pre>
        <p>Define a visualization of the distribution of events in the <code>d6</code> model:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">d6vis</span><span> = </span><span class="type-name">BarChart</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Rational</span><span>, </span><span class="type-name">ConditionalProbabilityTable</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Rational</span><span>], </span><span class="type-name">String</span><span>](
  () =&gt; </span><span class="identifier">d6</span><span>,
  </span><span class="identifier">colorOf</span><span> = </span><span class="identifier">_</span><span> =&gt; </span><span class="type-name">Color</span><span>.</span><span class="identifier">blue</span><span>,
  </span><span class="identifier">xAxis</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="type-name">Rational</span><span>(</span><span class="number-literal">0</span><span>)),
  </span><span class="identifier">title</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="string-literal">&quot;d6&quot;</span><span>),
  </span><span class="identifier">labelAngle</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="number-literal">0d</span><span> *: </span><span class="identifier">angleDouble</span><span>.</span><span class="identifier">degree</span><span>),
  </span><span class="identifier">drawKey</span><span> = </span><span class="boolean-literal">false</span><span>)</span></code></pre>
        <p>Create an SVG</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">d6vis</span><span>.</span><span class="identifier">svg</span><span>[</span><span class="type-name">IO</span><span>](</span><span class="string-literal">&quot;d6.svg&quot;</span><span>).</span><span class="identifier">unsafeRunSync</span><span>()</span></code></pre>
        <p><img src="/tutorial/images/d6.svg" alt="d6"></p>
        
        <h2 id="sampler" class="section"><a class="anchor-link left" href="#sampler"><i class="icofont-laika">&#xef71;</i></a>Sampler</h2>
        <p>The <code>Sampler</code> typeclass provides the ability to &quot;execute&quot; the model and product
        a random sample via the <code>sample</code> method.</p>
        <p>It&#39;s type signature is:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">sample</span><span>(</span><span class="identifier">gen</span><span>: </span><span class="type-name">Generator</span><span>)(</span><span class="keyword">implicit</span><span> </span><span class="identifier">spireDist</span><span>: </span><span class="type-name">Dist</span><span>[</span><span class="type-name">V</span><span>], </span><span class="identifier">ringV</span><span>: </span><span class="type-name">Ring</span><span>[</span><span class="type-name">V</span><span>], </span><span class="identifier">orderV</span><span>: </span><span class="type-name">Order</span><span>[</span><span class="type-name">V</span><span>]): </span><span class="type-name">A</span></code></pre>
        <p>These imports make available a <code>Generator</code> as source of entropy</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">spire</span><span>.</span><span class="identifier">random</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">rng</span><span> = </span><span class="type-name">Random</span><span>.</span><span class="identifier">generatorFromSeed</span><span>(</span><span class="type-name">Seed</span><span>(</span><span class="number-literal">42</span><span>))
</span><span class="comment">// rng: spire.random.rng.Cmwc5 = spire.random.rng.Cmwc5@63a24fcb</span></code></pre>
        <p>And then the <code>.sample</code> syntax:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">axle</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">sampler</span><span>.</span><span class="identifier">_</span></code></pre>
        <p>Note that it must be provided with a Spire <code>Generator</code>.
        It also requires context bounds on the value type <code>V</code> that give the method
        the ability to produces values with a distribution conforming to the probability model.</p>
        <pre><code class="nohighlight"><span>(</span><span class="number-literal">1</span><span> </span><span class="identifier">to</span><span> </span><span class="number-literal">10</span><span>) </span><span class="identifier">map</span><span> { </span><span class="identifier">_</span><span> =&gt; </span><span class="identifier">fairCoin</span><span>.</span><span class="identifier">sample</span><span>(</span><span class="identifier">rng</span><span>) }
</span><span class="comment">// res1: IndexedSeq[Symbol] = Vector(
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;TAIL,
//   &#39;TAIL,
//   &#39;HEAD,
//   &#39;TAIL,
//   &#39;TAIL,
//   &#39;TAIL,
//   &#39;HEAD
// )
</span><span>
(</span><span class="number-literal">1</span><span> </span><span class="identifier">to</span><span> </span><span class="number-literal">10</span><span>) </span><span class="identifier">map</span><span> { </span><span class="identifier">_</span><span> =&gt; </span><span class="identifier">biasedCoin</span><span>.</span><span class="identifier">sample</span><span>(</span><span class="identifier">rng</span><span>) }
</span><span class="comment">// res2: IndexedSeq[Symbol] = Vector(
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD,
//   &#39;HEAD
// )
</span><span>
(</span><span class="number-literal">1</span><span> </span><span class="identifier">to</span><span> </span><span class="number-literal">10</span><span>) </span><span class="identifier">map</span><span> { </span><span class="identifier">_</span><span> =&gt; </span><span class="identifier">d6</span><span>.</span><span class="identifier">sample</span><span>(</span><span class="identifier">rng</span><span>) }
</span><span class="comment">// res3: IndexedSeq[Int] = Vector(3, 2, 5, 2, 6, 2, 6, 1, 1, 5)</span></code></pre>
        <p>Simulate 1k rolls of one d6</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">rolls</span><span> = (</span><span class="number-literal">0</span><span> </span><span class="identifier">until</span><span> </span><span class="number-literal">1000</span><span>) </span><span class="identifier">map</span><span> { </span><span class="identifier">_</span><span> =&gt; </span><span class="identifier">d6</span><span>.</span><span class="identifier">sample</span><span>(</span><span class="identifier">rng</span><span>) }</span></code></pre>
        <p>Then tally them</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">ringInt</span><span>: </span><span class="type-name">CRing</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="identifier">spire</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="type-name">IntAlgebra</span><span>
</span><span class="comment">// ringInt: CRing[Int] = spire.std.IntAlgebra@2cdd991a
</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">axle</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">talliable</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">oneKd6Histogram</span><span> = </span><span class="identifier">rolls</span><span>.</span><span class="identifier">tally</span><span>
</span><span class="comment">// oneKd6Histogram: Map[Int, Int] = Map(
//   5 -&gt; 167,
//   1 -&gt; 160,
//   6 -&gt; 176,
//   2 -&gt; 171,
//   3 -&gt; 164,
//   4 -&gt; 162
// )</span></code></pre>
        <p>Create a visualization</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">d6oneKvis</span><span> = </span><span class="type-name">BarChart</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>, </span><span class="type-name">Map</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>], </span><span class="type-name">String</span><span>](
  () =&gt; </span><span class="identifier">oneKd6Histogram</span><span>,
  </span><span class="identifier">colorOf</span><span> = </span><span class="identifier">_</span><span> =&gt; </span><span class="type-name">Color</span><span>.</span><span class="identifier">blue</span><span>,
  </span><span class="identifier">xAxis</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="number-literal">0</span><span>),
  </span><span class="identifier">title</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="string-literal">&quot;1,000 d6 samples&quot;</span><span>),
  </span><span class="identifier">labelAngle</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="number-literal">0d</span><span> *: </span><span class="identifier">angleDouble</span><span>.</span><span class="identifier">degree</span><span>),
  </span><span class="identifier">drawKey</span><span> = </span><span class="boolean-literal">false</span><span>)</span></code></pre>
        <p>Create SVG</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">d6oneKvis</span><span>.</span><span class="identifier">svg</span><span>[</span><span class="type-name">IO</span><span>](</span><span class="string-literal">&quot;d6-1Ksamples.svg&quot;</span><span>).</span><span class="identifier">unsafeRunSync</span><span>()</span></code></pre>
        <p><img src="/tutorial/images/d6-1Ksamples.svg" alt="1k d6 samples"></p>
        
        <h2 id="sigma-algebra-regions" class="section"><a class="anchor-link left" href="#sigma-algebra-regions"><i class="icofont-laika">&#xef71;</i></a>Sigma Algebra Regions</h2>
        <p>The sealed <code>Region[A]</code> trait is extended by the following case classes
        that form a way to describe expressions on the event-space of a probability model.
        In Measure Theory, these expressions are said to form a &quot;sigma-algebra&quot; (&quot;σ-algebra&quot;)</p>
        <p>In order of arity, they case classes extending this trait are:</p>
        
        <h3 id="arity-0" class="section"><a class="anchor-link left" href="#arity-0"><i class="icofont-laika">&#xef71;</i></a>Arity 0</h3>
        <ul>
          <li><code>RegionEmpty</code> never matches any events or probability mass</li>
          <li><code>RegionAll</code> always matches all events and probability mass</li>
        </ul>
        
        <h3 id="arity-1-not-including-typeclass-witnesses" class="section"><a class="anchor-link left" href="#arity-1-not-including-typeclass-witnesses"><i class="icofont-laika">&#xef71;</i></a>Arity 1 (not including typeclass witnesses)</h3>
        <ul>
          <li><code>RegionEq</code> matches when an event is equal to the supplied object, with respect to the supplied <code>cats.kernel.Eq[A]</code> witness.</li>
          <li><code>RegionIf</code> matches when the supplied condition function returns <code>true</code></li>
          <li><code>RegionSet</code> matches when an event is contained within the supplied <code>Set[A]</code>.</li>
          <li><code>RegionNegate</code> negates the supplied region.</li>
          <li><code>RegionGTE</code> is true when an event is greater than or equal to the supplied object, with respect to the supplied <code>cats.kernel.Order[A]</code></li>
          <li><code>RegionLTE</code> is true when an event is less than or equal to the supplied object, with respect to the supplied <code>cats.kernel.Order[A]</code></li>
        </ul>
        
        <h3 id="arity-2" class="section"><a class="anchor-link left" href="#arity-2"><i class="icofont-laika">&#xef71;</i></a>Arity 2</h3>
        <ul>
          <li><code>RegionAnd</code> is the conjunction of both arguments.  It can be created using the <code>and</code> method in the <code>Region</code> trait.</li>
          <li><code>RegionOr</code> is the disjunction of both arguments.  It can be created using the <code>or</code> method in the <code>Region</code> trait.</li>
        </ul>
        <p>Note that a &quot;Random Variable&quot; does not appear in this discussion.
        The <code>axle.probability.Variable</code> class does define a <code>is</code> method that returns a <code>RegionEq</code>,
        but the probability models themselves are not concerned with the notion of a
        <code>Variable</code>.
        They are simply models over regions of events on their single, opaque type
        that adhere to the laws of probability.</p>
        <p>The eventual formalization of <code>Region</code> should connect it with a σ-algebra from Meaasure Theory.</p>
        
        <h2 id="kolmogorov-for-querying-probability-models" class="section"><a class="anchor-link left" href="#kolmogorov-for-querying-probability-models"><i class="icofont-laika">&#xef71;</i></a>Kolmogorov for querying Probability Models</h2>
        
        <h3 id="probabilityof-aka-p" class="section"><a class="anchor-link left" href="#probabilityof-aka-p"><i class="icofont-laika">&#xef71;</i></a>probabilityOf (aka &quot;P&quot;)</h3>
        <p>The method <code>probabilityOf</code> is defined in terms of a <code>Region</code>.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">probabilityOf</span><span>(</span><span class="identifier">predicate</span><span>: </span><span class="type-name">Region</span><span>[</span><span class="type-name">A</span><span>])(</span><span class="keyword">implicit</span><span> </span><span class="identifier">fieldV</span><span>: </span><span class="type-name">Field</span><span>[</span><span class="type-name">V</span><span>]): </span><span class="type-name">V</span></code></pre>
        <p>Note that <code>probabilityOf</code> is aliased to <code>P</code> in <code>axle.syntax.kolmogorov._</code></p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">axle</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">kolmogorov</span><span>.</span><span class="identifier">_</span></code></pre>
        <p>The probability of a <code>head</code> for a single toss of a fair coin is <code>1/2</code></p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">fairCoin</span><span>.</span><span class="type-name">P</span><span>(</span><span class="type-name">RegionEq</span><span>(</span><span class="identifier">head</span><span>))
</span><span class="comment">// res5: Rational = 1/2</span></code></pre>
        <p>The probability that a toss is not <code>head</code> is also <code>1/2</code>.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">fairCoin</span><span>.</span><span class="type-name">P</span><span>(</span><span class="type-name">RegionNegate</span><span>(</span><span class="type-name">RegionEq</span><span>(</span><span class="identifier">head</span><span>)))
</span><span class="comment">// res6: Rational = 1/2</span></code></pre>
        <p>The probability that a toss is both <code>head</code> and <code>tail</code> is zero.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">fairCoin</span><span>.</span><span class="type-name">P</span><span>(</span><span class="type-name">RegionEq</span><span>(</span><span class="identifier">head</span><span>) </span><span class="identifier">and</span><span> </span><span class="type-name">RegionEq</span><span>(</span><span class="identifier">tail</span><span>))
</span><span class="comment">// res7: Rational = 0</span></code></pre>
        <p>The probability that a toss is either <code>head</code> or <code>tail</code> is one.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">fairCoin</span><span>.</span><span class="type-name">P</span><span>(</span><span class="type-name">RegionEq</span><span>(</span><span class="identifier">head</span><span>) </span><span class="identifier">or</span><span> </span><span class="type-name">RegionEq</span><span>(</span><span class="identifier">tail</span><span>))
</span><span class="comment">// res8: Rational = 1</span></code></pre>
        
        <h3 id="kolmogorov-s-axioms" class="section"><a class="anchor-link left" href="#kolmogorov-s-axioms"><i class="icofont-laika">&#xef71;</i></a>Kolmogorov&#39;s Axioms</h3>
        <p>The single <code>probabilityOf</code> method together with the <code>Region</code> trait
        is enough to define Kolmogorov&#39;s Axioms of Probability.
        The axioms are implemented in <code>axle.laws.KolmogorovProbabilityAxioms</code> and
        checked during testing with ScalaCheck.</p>
        
        <h4 id="basic-measure" class="section"><a class="anchor-link left" href="#basic-measure"><i class="icofont-laika">&#xef71;</i></a>Basic Measure</h4>
        <p>Probabilities are non-negative.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">model</span><span>.</span><span class="type-name">P</span><span>(</span><span class="identifier">region</span><span>) &gt;= </span><span class="type-name">Field</span><span>[</span><span class="type-name">V</span><span>].</span><span class="identifier">zero</span></code></pre>
        
        <h4 id="unit-measure" class="section"><a class="anchor-link left" href="#unit-measure"><i class="icofont-laika">&#xef71;</i></a>Unit Measure</h4>
        <p>The sum the probabilities of all possible events is <code>one</code></p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">model</span><span>.</span><span class="type-name">P</span><span>(</span><span class="type-name">RegionAll</span><span>()) === </span><span class="type-name">Field</span><span>[</span><span class="type-name">V</span><span>].</span><span class="identifier">one</span></code></pre>
        
        <h4 id="combination" class="section"><a class="anchor-link left" href="#combination"><i class="icofont-laika">&#xef71;</i></a>Combination</h4>
        <p>For disjoint event regions, <code>e1</code> and <code>e2</code>, the probability of their disjunction <code>e1 or e2</code>
        is equal to the sum of their independent probabilities.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>(!((</span><span class="identifier">e1</span><span> </span><span class="identifier">and</span><span> </span><span class="identifier">e2</span><span>) === </span><span class="type-name">RegionEmpty</span><span>() )) || (</span><span class="identifier">model</span><span>.</span><span class="type-name">P</span><span>(</span><span class="identifier">e1</span><span> </span><span class="identifier">or</span><span> </span><span class="identifier">e2</span><span>) === </span><span class="identifier">model</span><span>.</span><span class="type-name">P</span><span>(</span><span class="identifier">e1</span><span>) + </span><span class="identifier">model</span><span>.</span><span class="type-name">P</span><span>(</span><span class="identifier">e2</span><span>))</span></code></pre>
        
        <h2 id="bayes-theorem-conditioning-and-filtering" class="section"><a class="anchor-link left" href="#bayes-theorem-conditioning-and-filtering"><i class="icofont-laika">&#xef71;</i></a>Bayes Theorem, Conditioning, and Filtering</h2>
        <p>The <code>Bayes</code> typeclass implements the conditioning of a probability model
        via the <code>filter</code> (<code>|</code> is also an alias).</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">filter</span><span>(</span><span class="identifier">predicate</span><span>: </span><span class="type-name">Region</span><span>[</span><span class="type-name">A</span><span>])(</span><span class="keyword">implicit</span><span> </span><span class="identifier">fieldV</span><span>: </span><span class="type-name">Field</span><span>[</span><span class="type-name">V</span><span>]): </span><span class="type-name">M</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">V</span><span>]</span></code></pre>
        <p>Syntax is available via this import</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">axle</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">bayes</span><span>.</span><span class="identifier">_</span></code></pre>
        <p><code>filter</code> -- along with <code>probabilityOf</code> from <code>Kolomogorov</code> -- allows Bayes&#39; Theorem
        to be expressed and checked with ScalaCheck.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">model</span><span>.</span><span class="identifier">filter</span><span>(</span><span class="identifier">b</span><span>).</span><span class="type-name">P</span><span>(</span><span class="identifier">a</span><span>) * </span><span class="identifier">model</span><span>.</span><span class="type-name">P</span><span>(</span><span class="identifier">b</span><span>) === </span><span class="identifier">model</span><span>.</span><span class="identifier">filter</span><span>(</span><span class="identifier">a</span><span>).</span><span class="type-name">P</span><span>(</span><span class="identifier">b</span><span>) * </span><span class="identifier">model</span><span>.</span><span class="type-name">P</span><span>(</span><span class="identifier">a</span><span>)</span></code></pre>
        <p>For non-zero <code>model.P(a)</code> and <code>model.P(b)</code></p>
        <p>The theorem is more recognizable as <code>P(A|B) = P(B|A) * P(A) / P(B)</code></p>
        <p>Filter is easier to motivate with composite types, but two examples
        with a d6 show the expected semantics:</p>
        <p>Filtering the d6 roll model to 1 and 5:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">d6</span><span>.</span><span class="identifier">filter</span><span>(</span><span class="type-name">RegionIf</span><span>(</span><span class="identifier">_</span><span> % </span><span class="number-literal">4</span><span> == </span><span class="number-literal">1</span><span>))
</span><span class="comment">// res9: ConditionalProbabilityTable[Int, Rational] = ConditionalProbabilityTable(
//   p = Map(5 -&gt; 1/2, 1 -&gt; 1/2)
// )</span></code></pre>
        <p>Filter the d6 roll model to 1, 2, and 3:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">d6</span><span>.</span><span class="identifier">filter</span><span>(</span><span class="type-name">RegionLTE</span><span>(</span><span class="number-literal">3</span><span>))
</span><span class="comment">// res10: ConditionalProbabilityTable[Int, Rational] = ConditionalProbabilityTable(
//   p = Map(1 -&gt; 1/3, 2 -&gt; 1/3, 3 -&gt; 1/3)
// )</span></code></pre>
        
        <h2 id="probability-model-as-monads" class="section"><a class="anchor-link left" href="#probability-model-as-monads"><i class="icofont-laika">&#xef71;</i></a>Probability Model as Monads</h2>
        <p>The <code>pure</code>, <code>map</code>, and <code>flatMap</code> methods of <code>cats.Monad</code> are defined
        for <code>ConditionalProbabilityTable</code>, <code>TallyDistribution</code>.</p>
        
        <h3 id="monad-laws" class="section"><a class="anchor-link left" href="#monad-laws"><i class="icofont-laika">&#xef71;</i></a>Monad Laws</h3>
        <p>The short version is that the three methods are constrained by a few laws that
        make them very useful for composing programs.
        Those laws are:</p>
        <ul>
          <li>Left identity: <code>pure(x).flatMap(f) === f(x)</code></li>
          <li>Right identity: <code>model.flatMap(pure) === model</code></li>
          <li>Associativity: <code>model.flatMap(f).flatMap(g) === model.flatMap(f.flatMap(g))</code></li>
        </ul>
        
        <h3 id="monad-syntax" class="section"><a class="anchor-link left" href="#monad-syntax"><i class="icofont-laika">&#xef71;</i></a>Monad Syntax</h3>
        <p>There is syntax support in <code>cats.implicits._</code> for all three methods.</p>
        <p>However, due to limitations of Scala&#39;s type inference, it cannot see
        <code>ConditionalProbabilityTable[E, V]</code> as the <code>M[_]</code> expected by <code>Monad</code>.</p>
        <p>The most straigtfoward workaround is just to conjure the monad witness
        directly and use it, passing the model in as the sole argument to the
        first parameter group.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">monad</span><span> = </span><span class="type-name">ConditionalProbabilityTable</span><span>.</span><span class="identifier">monadWitness</span><span>[</span><span class="type-name">Rational</span><span>]

</span><span class="identifier">monad</span><span>.</span><span class="identifier">flatMap</span><span>(</span><span class="identifier">d6</span><span>) { </span><span class="identifier">a</span><span> =&gt; </span><span class="identifier">monad</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">d6</span><span>) { </span><span class="identifier">b</span><span> =&gt; </span><span class="identifier">a</span><span> + </span><span class="identifier">b</span><span> } }</span></code></pre>
        <p>Another strategy to use <code>map</code> and <code>flatMap</code> directly on
        the model is a type that can be seen as <code>M[_]</code> along with
        a type annotation:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">CPTR</span><span>[</span><span class="type-name">E</span><span>] = </span><span class="type-name">ConditionalProbabilityTable</span><span>[</span><span class="type-name">E</span><span>, </span><span class="type-name">Rational</span><span>]

(</span><span class="identifier">d6</span><span>: </span><span class="type-name">CPTR</span><span>[</span><span class="type-name">Int</span><span>]).</span><span class="identifier">flatMap</span><span> { </span><span class="identifier">a</span><span> =&gt; (</span><span class="identifier">d6</span><span>: </span><span class="type-name">CPTR</span><span>[</span><span class="type-name">Int</span><span>]).</span><span class="identifier">map</span><span> { </span><span class="identifier">b</span><span> =&gt; </span><span class="identifier">a</span><span> + </span><span class="identifier">b</span><span> } }</span></code></pre>
        <p>Or similar to use a for comprehension:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">for</span><span> {
  </span><span class="identifier">a</span><span> &lt;- </span><span class="identifier">d6</span><span>: </span><span class="type-name">CPTR</span><span>[</span><span class="type-name">Int</span><span>]
  </span><span class="identifier">b</span><span> &lt;- </span><span class="identifier">d6</span><span>: </span><span class="type-name">CPTR</span><span>[</span><span class="type-name">Int</span><span>]
} </span><span class="keyword">yield</span><span> </span><span class="identifier">a</span><span> + </span><span class="identifier">b</span></code></pre>
        
        <h3 id="chaining-models" class="section"><a class="anchor-link left" href="#chaining-models"><i class="icofont-laika">&#xef71;</i></a>Chaining models</h3>
        <p>Chain two events&#39; models</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">bothCoinsModel</span><span> = </span><span class="identifier">monad</span><span>.</span><span class="identifier">flatMap</span><span>(</span><span class="identifier">fairCoin</span><span>) { </span><span class="identifier">flip1</span><span> =&gt;
  </span><span class="identifier">monad</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">fairCoin</span><span>) { </span><span class="identifier">flip2</span><span> =&gt;
    (</span><span class="identifier">flip1</span><span>, </span><span class="identifier">flip2</span><span>)
  }
}
</span><span class="comment">// bothCoinsModel: ConditionalProbabilityTable[(Symbol, Symbol), Rational] = ConditionalProbabilityTable(
//   p = HashMap(
//     (&#39;HEAD, &#39;HEAD) -&gt; 1/4,
//     (&#39;TAIL, &#39;HEAD) -&gt; 1/4,
//     (&#39;TAIL, &#39;TAIL) -&gt; 1/4,
//     (&#39;HEAD, &#39;TAIL) -&gt; 1/4
//   )
// )</span></code></pre>
        <p>This creates a model on events of type <code>(Symbol, Symbol)</code></p>
        <p>It can be queried with <code>P</code> using <code>RegionIf</code> to check fields within the <code>Tuple2</code>.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">TWOFLIPS</span><span> = (</span><span class="type-name">Symbol</span><span>, </span><span class="type-name">Symbol</span><span>)

</span><span class="identifier">bothCoinsModel</span><span>.</span><span class="type-name">P</span><span>(</span><span class="type-name">RegionIf</span><span>[</span><span class="type-name">TWOFLIPS</span><span>](</span><span class="identifier">_</span><span class="number-literal">._1</span><span> == </span><span class="identifier">head</span><span>) </span><span class="identifier">and</span><span> </span><span class="type-name">RegionIf</span><span>[</span><span class="type-name">TWOFLIPS</span><span>](</span><span class="identifier">_</span><span class="number-literal">._2</span><span> == </span><span class="identifier">head</span><span>))
</span><span class="comment">// res14: Rational = 1/4
</span><span>
</span><span class="identifier">bothCoinsModel</span><span>.</span><span class="type-name">P</span><span>(</span><span class="type-name">RegionIf</span><span>[</span><span class="type-name">TWOFLIPS</span><span>](</span><span class="identifier">_</span><span class="number-literal">._1</span><span> == </span><span class="identifier">head</span><span>) </span><span class="identifier">or</span><span> </span><span class="type-name">RegionIf</span><span>[</span><span class="type-name">TWOFLIPS</span><span>](</span><span class="identifier">_</span><span class="number-literal">._2</span><span> == </span><span class="identifier">head</span><span>))
</span><span class="comment">// res15: Rational = 3/4</span></code></pre>
        
        <h2 id="summing-two-dice-rolls" class="section"><a class="anchor-link left" href="#summing-two-dice-rolls"><i class="icofont-laika">&#xef71;</i></a>Summing two dice rolls</h2>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">twoDiceSummed</span><span> = </span><span class="identifier">monad</span><span>.</span><span class="identifier">flatMap</span><span>(</span><span class="identifier">d6</span><span>) { </span><span class="identifier">a</span><span> =&gt;
  </span><span class="identifier">monad</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">d6</span><span>) { </span><span class="identifier">b</span><span> =&gt;
    </span><span class="identifier">a</span><span> + </span><span class="identifier">b</span><span>
  }
}
</span><span class="comment">// twoDiceSummed: ConditionalProbabilityTable[Int, Rational] = ConditionalProbabilityTable(
//   p = HashMap(
//     5 -&gt; 1/9,
//     10 -&gt; 1/12,
//     6 -&gt; 5/36,
//     9 -&gt; 1/9,
//     2 -&gt; 1/36,
//     12 -&gt; 1/36,
//     7 -&gt; 1/6,
//     3 -&gt; 1/18,
//     11 -&gt; 1/18,
//     8 -&gt; 5/36,
//     4 -&gt; 1/12
//   )
// )</span></code></pre>
        <p>Create a visualization</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">monadicChart</span><span> = </span><span class="type-name">BarChart</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Rational</span><span>, </span><span class="type-name">ConditionalProbabilityTable</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Rational</span><span>], </span><span class="type-name">String</span><span>](
  () =&gt; </span><span class="identifier">twoDiceSummed</span><span>,
  </span><span class="identifier">colorOf</span><span> = </span><span class="identifier">_</span><span> =&gt; </span><span class="type-name">Color</span><span>.</span><span class="identifier">blue</span><span>,
  </span><span class="identifier">xAxis</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="type-name">Rational</span><span>(</span><span class="number-literal">0</span><span>)),
  </span><span class="identifier">title</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="string-literal">&quot;d6 + d6&quot;</span><span>),
  </span><span class="identifier">labelAngle</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="number-literal">0d</span><span> *: </span><span class="identifier">angleDouble</span><span>.</span><span class="identifier">degree</span><span>),
  </span><span class="identifier">drawKey</span><span> = </span><span class="boolean-literal">false</span><span>)</span></code></pre>
        <p>Create SVG</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">monadicChart</span><span>.</span><span class="identifier">svg</span><span>[</span><span class="type-name">IO</span><span>](</span><span class="string-literal">&quot;distributionMonad.svg&quot;</span><span>).</span><span class="identifier">unsafeRunSync</span><span>()</span></code></pre>
        <p><img src="/tutorial/images/distributionMonad.svg" alt="Monadic d6 + d6"></p>
        
        <h3 id="iffy" class="section"><a class="anchor-link left" href="#iffy"><i class="icofont-laika">&#xef71;</i></a>Iffy</h3>
        <p>A stochastic version of <code>if</code> (aka <code>iffy</code>) can be implemented in terms of <code>flatMap</code>
        using this pattern for any probability model type <code>M[A]</code> such that a <code>Monad</code> is defined.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">iffy</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">M</span><span>[</span><span class="identifier">_</span><span>]: </span><span class="type-name">Monad</span><span>](
  </span><span class="identifier">input</span><span>      : </span><span class="type-name">M</span><span>[</span><span class="type-name">A</span><span>],
  </span><span class="identifier">predicate</span><span>  : </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">Boolean</span><span>,
  </span><span class="identifier">trueClause</span><span> : </span><span class="type-name">M</span><span>[</span><span class="type-name">B</span><span>],
  </span><span class="identifier">falseClause</span><span>: </span><span class="type-name">M</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">M</span><span>[</span><span class="type-name">B</span><span>] =
  </span><span class="identifier">input</span><span>.</span><span class="identifier">flatMap</span><span> { </span><span class="identifier">i</span><span> =&gt;
    </span><span class="keyword">if</span><span>( </span><span class="identifier">predicate</span><span>(</span><span class="identifier">i</span><span>) ) {
      </span><span class="identifier">trueClause</span><span>
    } </span><span class="keyword">else</span><span> {
      </span><span class="identifier">falseClause</span><span>
    }
  }</span></code></pre>
        <p>An example of that pattern: &quot;if heads, d6+d6, otherwise d10+d10&quot;</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="type-name">Eq</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">headsD6D6taildD10D10</span><span> = </span><span class="identifier">monad</span><span>.</span><span class="identifier">flatMap</span><span>(</span><span class="identifier">fairCoin</span><span>) { </span><span class="identifier">side</span><span> =&gt;
  </span><span class="keyword">if</span><span>( </span><span class="type-name">Eq</span><span>[</span><span class="type-name">Symbol</span><span>].</span><span class="identifier">eqv</span><span>(</span><span class="identifier">side</span><span>, </span><span class="identifier">head</span><span>) ) {
    </span><span class="identifier">monad</span><span>.</span><span class="identifier">flatMap</span><span>(</span><span class="identifier">d6</span><span>) { </span><span class="identifier">a</span><span> =&gt; </span><span class="identifier">monad</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">d6</span><span>) { </span><span class="identifier">b</span><span> =&gt; </span><span class="identifier">a</span><span> + </span><span class="identifier">b</span><span> } }
  } </span><span class="keyword">else</span><span> {
    </span><span class="identifier">monad</span><span>.</span><span class="identifier">flatMap</span><span>(</span><span class="identifier">d10</span><span>) { </span><span class="identifier">a</span><span> =&gt; </span><span class="identifier">monad</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">d10</span><span>) { </span><span class="identifier">b</span><span> =&gt; </span><span class="identifier">a</span><span> + </span><span class="identifier">b</span><span> } }
  }
}
</span><span class="comment">// headsD6D6taildD10D10: ConditionalProbabilityTable[Int, Rational] = ConditionalProbabilityTable(
//   p = HashMap(
//     5 -&gt; 17/225,
//     10 -&gt; 13/150,
//     14 -&gt; 7/200,
//     20 -&gt; 1/200,
//     6 -&gt; 17/180,
//     9 -&gt; 43/450,
//     13 -&gt; 1/25,
//     2 -&gt; 17/900,
//     17 -&gt; 1/50,
//     12 -&gt; 53/900,
//     7 -&gt; 17/150,
//     3 -&gt; 17/450,
//     18 -&gt; 3/200,
//     16 -&gt; 1/40,
//     11 -&gt; 7/90,
//     8 -&gt; 47/450,
//     19 -&gt; 1/100,
//     4 -&gt; 17/300,
//     15 -&gt; 3/100
//   )
// )</span></code></pre>
        <p>Create visualization</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">iffyChart</span><span> = </span><span class="type-name">BarChart</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Rational</span><span>, </span><span class="type-name">ConditionalProbabilityTable</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Rational</span><span>], </span><span class="type-name">String</span><span>](
  () =&gt; </span><span class="identifier">headsD6D6taildD10D10</span><span>,
  </span><span class="identifier">colorOf</span><span> = </span><span class="identifier">_</span><span> =&gt; </span><span class="type-name">Color</span><span>.</span><span class="identifier">blue</span><span>,
  </span><span class="identifier">xAxis</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="type-name">Rational</span><span>(</span><span class="number-literal">0</span><span>)),
  </span><span class="identifier">title</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="string-literal">&quot;if heads, d6+d6, else d10+d10&quot;</span><span>),
  </span><span class="identifier">labelAngle</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="number-literal">0d</span><span> *: </span><span class="identifier">angleDouble</span><span>.</span><span class="identifier">degree</span><span>),
  </span><span class="identifier">drawKey</span><span> = </span><span class="boolean-literal">false</span><span>)</span></code></pre>
        <p>Create SVG</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">iffyChart</span><span>.</span><span class="identifier">svg</span><span>[</span><span class="type-name">IO</span><span>](</span><span class="string-literal">&quot;iffy.svg&quot;</span><span>).</span><span class="identifier">unsafeRunSync</span><span>()</span></code></pre>
        <p><img src="/tutorial/images/iffy.svg" alt="heads => d6+d6, else d10+d10"></p>
        
        <h3 id="further-reading" class="section"><a class="anchor-link left" href="#further-reading"><i class="icofont-laika">&#xef71;</i></a>Further Reading</h3>
        <p>Motiviating the Monad typeclass is out of scope of this document.
        Please see the functional programming literature for more about monads
        and their relationship to functors, applicative functors, monoids, categories,
        and other structures.</p>
        <p>For some historical reading on the origins of probability monads,
        see the literature on the Giry Monad.</p>
        
        <h2 id="future-work" class="section"><a class="anchor-link left" href="#future-work"><i class="icofont-laika">&#xef71;</i></a>Future work</h2>
        
        <h3 id="measure-theory" class="section"><a class="anchor-link left" href="#measure-theory"><i class="icofont-laika">&#xef71;</i></a>Measure Theory</h3>
        <p>Further refining and extending Axle to incorporate Measure Theory is a likely follow-on step.</p>
        
        <h3 id="markov-categories" class="section"><a class="anchor-link left" href="#markov-categories"><i class="icofont-laika">&#xef71;</i></a>Markov Categories</h3>
        <p>As an alternative to Measure Theory, see Tobias Fritz&#39;s work on Markov Categories</p>
        
        <h3 id="probabilistic-and-differentiable-programming" class="section"><a class="anchor-link left" href="#probabilistic-and-differentiable-programming"><i class="icofont-laika">&#xef71;</i></a>Probabilistic and Differentiable Programming</h3>
        <p>In general, the explosion of work on probabilistic and differentible programming is fertile ground for Axle&#39;s lawful approach.</p>

      </main>

    </div>

  </body>
</html>